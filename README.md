# Capslock - Playwright + Typescript E2E Tests

## Overview

This repository contains an end-to-end automation framework built with Playwright and TypeScript, focused on validating the landing page experience.

## Scope

Automation covers the most critical user journeys and validation scenarios on the landing page.

## Tech Stack

- Playwright Test
- TypeScript
- Node.js

## Project Structure

The framework follows a Page Object Model approach with a clear separation between page behavior, reusable UI components, test specifications, and supporting utilities.

The structure is intentionally lightweight, avoiding unnecessary abstractions while remaining easy to extend as test coverage grows.

```
capslock-playwright-ts/
├── node_modules/                                 # Project dependencies
├── playwright-report/                            # Playwright HTML reports
├── src/
│   ├── pages/
│   │   ├── sections/
│   │   │   ├── blocks/
│   │   │   │   └── *.block.ts                   # Section block components
│   │   │   ├── estimate-wizard/
│   │   │   │   ├── steps/
│   │   │   │   │   └── *.step.ts                # Wizard steps
│   │   │   │   └── *-wizard.section.ts          # Wizard section
│   │   │   └── *.section.ts                     # Landing page sections
│   │   │
│   │   └── *.page.ts                            # Page objects
│   │
│   ├── shared/                                  # Shared setup & helpers
│   │
│   ├── tests/                                   # Test specifications
│   │   ├── helpers/
│   │   │   └── *.setup.ts                       # Shared test setup
│   │   ├── landing-page-validation/
│   │   │   └── *-validations.spec.ts            # Validation test specifications
│   │   │
│   │   ├── landing-page-conversion.spec.ts      # Conversion test specifications
│   │   └── landing-page.spec.ts                 # Smoke test specifications
│   │
│   └── utils/                                   # Test utilities & data
│       ├── constants/
│       │   └── *.constants.ts                   # Shared constants
│       └── test-data/
│           └── *.data.ts                        # Reusable test data
│
├── test-results/                                # Failure artifacts generated by Playwright (screenshots, videos, traces)
│
├── .env                                         # Environment variables
├── .gitignore                                   # Git ignore rules
├── package-lock.json                            # npm dependency lock file
├── package.json                                 # Project dependencies & scripts
├── playwright.config.ts                         # Playwright configuration
├── README.md                                    # Project documentation
└── tsconfig.json                                # TypeScript configuration
```

## Setup

Clone the repository: `git clone git@github.com:ionutQAA/capslock-playwright-ts.git`

Navigate to the project root: `cd capslock-playwright-ts`

Install dependencies: `npm install`

Install Playwright browsers: `npx playwright install`

## Running Tests

Run all tests: `npx playwright test`

To run a specific test file: `npx playwright test tests/landing-page.spec.ts`

To view the HTML report after running tests: `npx playwright show-report`

## Design Notes

### Scenario Selection

The selected scenarios focus on the most critical landing page user journeys, combining both validation-level checks and full conversion flows.
This approach maximises coverage of high-risk paths while keeping the test suite fast and maintainable.

### Scalability & Maintainability Improvements

As the project grows, the framework could be further improved by:

- Introducing test tagging to better separate smoke, regression, and extended suites.
- Adding visual regression checks to catch UI changes.
- Adding API-level checks where appropriate to reduce reliance on UI-only coverage.
- Tuning Playwright worker counts as the test suite grows to keep execution time predictable.

### Additional Improvements

- Integrating the framework into a CI pipeline with artifact retention for easier failure analysis.
- Adding reporting or dashboards to surface trends in test stability over time.
